Daniel Schley
Ryan Dunn

This program is a tokenizer which reads in a string of arbitrary length and content and breaks it up into its different token types, identifying and printing which type each token is.  The Tokenizer struct contains the input string that is to be tokenized.  It also contains the index of the base of the next token in the string as well as the current index of the string that is being examined.  The current pointer moves through the string until the current character is no longer in the current token, the segment of the string is printed and returned, and the base pointer moves to where the current pointer is in order to get ready to read through the string for the next token.

	The bulk of the work is done in the method TKGetNextToken which takes the tokenizer object which contains the information needed for TKGetNextToken to find the next token.  The logic inside TKGetNextToken basically narrows down the possibilities of what type of token the next token could be, then continues looking through the string until it violates the conditions to be of that token type.  From there a new method called makeToken takes the name of the token type, the input string, the base index of the current token, and the end index of the current token.  It dynamically allocates memory in the method and returns a pointer to TKGetNextToken, which is then returned from that method.

	The TKCreate method dynamically allocates memory for the Tokenizer struct as well as the string that is stored in it.  If the input string is empty or NULL, the base and current index are set to -1 which indicates to the loop in the main method to not run its course and search for tokens.

	The TKDestroy method frees the input string within the Tokenizer before freeing the Tokenizer itself in order to avoid problems with trying to access something within a pointer that is already freed.

	The main method first checks for the right amount of inputs and reads the command line's argv[1] and saves that as the input string.  Then TKCreate is invoked to get the TokenizerT struct.  A loop, that continues until the current index reaches the input's length, then calls TKGetNextToken and saves it to a string, freeing it after every call.  This token can be inserted into an array or some data structure but for the purpose of this project, saving all of the tokens in one place is unnecessary so it is freed immediately after it is stored in the 'token' variable.  Once the loop terminates, TKDestroy frees the TokenizerT struct and the program ends.  A neat feature added into the main method which for now remains commented out is the ability to read in a text file and tokenize the contents of the file.  This was done in order for us to test large amounts of test cases but it could be used practically as well.  In order to use it to read in a text file instead of an input string, it just has to be uncommented (lines 460-470).

	Some special cases in TKGetNextToken are that if the hex tag is followed by non hex digits, it prints the '0' as a decimal and 'x' followed by its trailing characters as a word.  Similarly '0' followed by non octal digits, it prints the '0' as a decimal and the following digits as their own separate decimal.  The tokenizer also accepts floats that have scientific notation when a lowercase 'e' appears immediately after a legal float, followed by an optional negative sign and any number of numeric characters.  Anything that does not fit the criteria to be one of the listed types of tokens or C operators is considered a bad token.  Bad tokens are still returned as a single character string (plus the null terminator) but are printed out as a hex number labeled as a bad token.  
The bad tokens are:
'#', '$', '@', '`', and any ascii character with a value greater than or equal to 0x80.
The characters ',",;,:,\,{,and } are not listed on the reference card as C operators, however they are accepted as good tokens because they are very often used in C.
The list of legal non-alphanumeric tokens are as follows:
'(', ')', '[', ']', '.', '-', '->', '--', '-=', '*', '*=', '*/', '&', '&&', '&=', '~', '+', '++', '+=', '/', '//', '/*', '%', '%=', '>', '>>', '>=', '>>=', '<', '<<', '<=', '<<=', '=', '==', '!', '!=', '^', '^=', '|', '||', '|=', '?', ':', ';', ',', ''', '"', '{', '}', and '\'.
